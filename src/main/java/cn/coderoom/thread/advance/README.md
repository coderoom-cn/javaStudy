
#线程

##同步与互斥

##阻塞与非阻塞

##线程安全机制

###CAS
cas是属于乐观锁的一种实现，是一种轻量级锁，juc中很多工具类的实现就是基于cas。
cas操作是线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。这是一种乐观策略，认为并发操作并不总会发生。

比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。

CAS容易出现ABA问题，如果线程T1读取值A之后，发生过两次写入，先由线程T2写回了b，又由t3写回了a，此时t1在写回比较时，值还是a，就无法判断是否发生过修改。

aba问题不一定会影响结果，但还是需要防范，解决的办法可以增加额外的标志位或者时间戳。juc工具包中提供了这样的类。
###同步
synchronized是最常用的线程同步手段之一，它是如何保证同一时刻只有一个线程可以进入临界区呢？
我们知道synchronized是对对象进行加锁，在JVM中，对象在内存中分为三块区域：对象头、实例数据和对齐填充。在对象头中保存了锁标志位和指向monitor对象的起始地址。当monitor被某个线程持有后，就会处于锁定状态，owner部分会指向持有monitor对象的线程。另外monitor中还有两个队列，用来存放进入及等待获取锁的线程。

synchronized应用在方法上时，在字节码中是通过方法的ACC_SYNCHRONIZED标志来实现的，synchronized应用在同步块上时，在字节码中是通过monitorenter和monitorexit实现的。

针对synchronized获取锁的方式，jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一线程再次获取锁，如果失败，就升级为CAS轻量级锁，如果再失败会短暂自旋，防止线程被系统挂起。最后如果以上都失败就是升级为重量级锁。
###锁

##线程池
线程池通过复用线程，避免线程频繁创建和销毁。

java的Executors工具类中，提供了5种类型线程池的创建方法，它们的特点和适用场景如下：

1. 固定大小线程池，特点是线程数固定，使用无界队列，适用于任务数量不均匀的场景、对内存压力不敏感，但系统负载比较敏感的场景；
2. cached线程池，特点是不限制线程数，适用于要求低延迟的短期任务场景；
3. 单线程线程池，也就是一个线程的固定线程池，适用于需要异步执行但需要保证任务顺序的场景；
4. scheduled线程池，适用于定期执行任务场景，支持按固定频率定期执行和按固定延时定期执行两种方式；
5. 工作窃取线程池，使用的ForkJoinPool，是固定并行度的多任务队列，适合任务执行时长不均匀的场景。

###原理

###使用场景
####cached线程池
大量短期任务
####固定线程池
系统资源比较紧张时
###常用配置

##JUC

##线程分析工具
jstack分析线程的运行状态，查找锁对象持有状况